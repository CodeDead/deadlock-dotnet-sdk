/// This file supplements code generated by CsWin32
using System.Diagnostics;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using Windows.Win32.Foundation;
using Win32Exception = System.ComponentModel.Win32Exception;

namespace Windows.Win32.System.Threading;

// TODO: finish definitions
partial struct PEB
{
    public PEB(PROCESS_BASIC_INFORMATION pbi)
    {
        this = pbi.GetPeb();
    }

    public bool InheritedAddressSpace => (BOOLEAN)Reserved1[0];
    public bool ReadImageFileExecOptions => (BOOLEAN)Reserved1[1];
    public bool IsBeingDebugged => (BOOLEAN)BeingDebugged;

    #region bit field

    public bool ImageUsesLargePages => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.ImageUsesLargePages);
    public bool IsProtectedProcess => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsProtectedProcess);
    public bool IsImageDynamicallyRelocated => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsImageDynamicallyRelocated);
    public bool SkipPatchingUser32Forwarders => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.SkipPatchingUser32Forwarders);
    public bool IsPackagedProcess => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsPackagedProcess);
    public bool IsAppContainer => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsAppContainer);
    public bool IsProtectedProcessLight => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsProtectedProcessLight);
    public bool IsLongPathAwareProcess => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsLongPathAwareProcess);

    [Flags]
    private enum R2_bits : byte
    {
        None = 0,
        ImageUsesLargePages,
        IsProtectedProcess,
        IsImageDynamicallyRelocated,
        SkipPatchingUser32Forwarders,
        IsPackagedProcess,
        IsAppContainer,
        IsProtectedProcessLight,
        IsLongPathAwareProcess
    }

    #endregion bit field

    public unsafe HANDLE Mutant => new((IntPtr)Reserved3._0);
    public unsafe IntPtr ImageBaseAddress => (IntPtr)Reserved3._1;

    /// <summary>
    /// Invoke ReadProcessMemory to copy the PED_LDR_DATA from the process's memory
    /// </summary>
    /// <param name="processId"></param>
    /// <exception cref="Win32Exception">ReadProcessMemory failed</exception>
    public unsafe PEB_LDR_DATA GetPebLdrData(uint processId)
    {
        using SafeProcessHandle hProcess = new(PInvoke.OpenProcess(PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ, true, processId), true);
        PEB_LDR_DATA ldr = default;
        nuint bytesRead = default;

        if (PInvoke.ReadProcessMemory(hProcess, Ldr, &ldr, (nuint)Marshal.SizeOf<PEB_LDR_DATA>(), &bytesRead))
            return ldr;
        else throw new Win32Exception();
    }

    /// <summary>
    /// Invoke ReadProcessMemory to copy the RTL_USER_PROCESS_PARAMETERS from the process's memory
    /// </summary>
    /// <param name="processId"></param>
    /// <returns></returns>
    /// <exception cref="Win32Exception">ReadProcessMemory failed</exception>
    public unsafe RTL_USER_PROCESS_PARAMETERS GetProcessParameters(uint processId)
    {
        Process.EnterDebugMode();
        using SafeProcessHandle hProcess = new(PInvoke.OpenProcess(PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ, true, processId), true);
        RTL_USER_PROCESS_PARAMETERS processParameters = default;
        nuint bytesRead = default;

        if (PInvoke.ReadProcessMemory(hProcess, ProcessParameters, &processParameters, (nuint)Marshal.SizeOf<RTL_USER_PROCESS_PARAMETERS>(), &bytesRead))
            return processParameters;
        else throw new Win32Exception();
    }

    public unsafe void* SubSystemData => Reserved4._0;
    public unsafe void* ProcessHeap => Reserved4._1;
    public unsafe void* FastPebLock => Reserved4._2;
    public unsafe void* IFEOKey => Reserved5;

    #region CrossProcessFlags

    public bool ProcessInJob => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessInJob);
    public bool ProcessInitializing => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessInitializing);
    public bool ProcessUsingVEH => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessUsingVEH);
    public bool ProcessUsingVCH => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessUsingVCH);
    public bool ProcessUsingFTH => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessUsingFTH);
    public bool ProcessPreviouslyThrottled => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessPreviouslyThrottled);
    public bool ProcessCurrentlyThrottled => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessCurrentlyThrottled);
    public bool ProcessImagesHotPatched => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessImagesHotPatched); // REDSTONE5 

    [Flags]
    private enum CrossProcessFlags : uint
    {
        None = 0,
        ProcessInJob = 0b0001,
        ProcessInitializing = 0b0010,
        ProcessUsingVEH = 0b0100,
        ProcessUsingVCH = 0b1000,
        ProcessUsingFTH = 0b1_0000,
        ProcessPreviouslyThrottled = 0b10_0000,
        ProcessCurrentlyThrottled = 0b100_0000,
        ProcessImagesHotPatched = 0b1000_0000
    }

    #endregion CrossProcessFlags

    public unsafe IntPtr KernelCallbackTable => (IntPtr)Reserved7;
    public unsafe IntPtr UserSharedInfoPtr => (IntPtr)Reserved7;
    public uint SystemReserved => Reserved8;
    public unsafe API_SET_NAMESPACE* ApiSetMap
    {
        get
        {
            fixed (void** res9_0 = &Reserved9._0)
                return (API_SET_NAMESPACE*)((nuint)res9_0 + sizeof(uint));
        }
    }
    public unsafe uint TlsExpansionCounter
    {
        get
        {
            fixed (void** res9_1 = &Reserved9._1)
                return *(uint*)(nuint)res9_1 + sizeof(uint);
        }
    }
    public unsafe void* TlsBitmap => Reserved9._2;
    public unsafe (uint, uint) TlsBitmapBits
    {
        get
        {
            fixed (void** res9_3 = &Reserved9._3)
                return (*(uint*)res9_3, *(uint*)((nuint)res9_3 + sizeof(uint)));
        }
    }

    public unsafe void* AnsiCodePageData // PCPTABLEINFO
        => Reserved9._4;
    public unsafe void* OemCodePageData // PCPTABLEINFO
        => Reserved9._5;
    public unsafe void* UnicodeCaseTableData // PNLSTABLEINFO
        => Reserved9._6;

    public unsafe uint NumberOfProcessors
    {
        get
        {
            fixed (void** res9_7 = &Reserved9._7)
            {
                return *(uint*)res9_7;
            }
        }
    }
    public unsafe uint NtGlobalFlag
    {
        get
        {
            fixed (void** res9_7 = &Reserved9._7)
                return *(uint*)((nuint)res9_7 + sizeof(uint));
        }
    }

    public unsafe ulong CriticalSectionTimeout => (ulong)Reserved9._8;
    public unsafe SIZE_T HeapSegmentReserve => (nuint)Reserved9._9;
    public unsafe SIZE_T HeapSegmentCommit => (nuint)Reserved9._10;
    public unsafe SIZE_T HeapDeCommitTotalFreeThreshold => (nuint)Reserved9._11;
    public unsafe SIZE_T HeapDeCommitFreeBlockThreshold => (nuint)Reserved9._12;

    public unsafe uint NumberOfHeaps
    {
        get
        {
            fixed (void** res9_13 = &Reserved9._13)
                return *(uint*)res9_13;
        }
    }
    public unsafe uint MaximumNumberOfHeaps
    {
        get
        {
            fixed (void** res9_13 = &Reserved9._13)
                return *(uint*)((nuint)res9_13 + sizeof(uint));
        }
    }
    public unsafe void** ProcessHeaps  // PHEAP
        => (void**)Reserved9._14;

    public unsafe void* GdiSharedHandleTable => Reserved9._15;
    public unsafe void* ProcessStarterHelper => Reserved9._16;
    public unsafe uint GdiDCAttributeList
    {
        get
        {
            fixed (void** res9_17 = &Reserved9._17)
                return *(uint*)res9_17;
        }
    }

    public unsafe void* LoaderLock // _RTL_CRITICAL_SECTION
    {
        get
        {
            fixed (void** res9_17 = &Reserved9._17)
                return *(void**)((nuint)res9_17 + sizeof(uint));
        }
    }

    //todo: https://sourcegraph.com/github.com/winsiderss/systeminformer@f5dc1c2d40a839315d2ffbb6c606b89943fc0595/-/blob/phnt/include/ntpebteb.h?L143
    //public unsafe uint OSMajorVersion
}
